<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Flappy Lamumu ‚Äî Sky Fix</title>
<style>
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;overflow:hidden;background:#000}
  #wrap{position:fixed;inset:0}
  #game{position:absolute;inset:0;display:block;background:#000}
  #score{
    position:absolute;top:8px;left:50%;transform:translateX(-50%);
    font-weight:800;font-size:18px;pointer-events:none
  }
  #overlay{position:absolute;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:8}
  #startPanel{
    width:min(600px,92vw);background:rgba(255,255,255,.96);border-radius:18px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);padding:22px 20px;text-align:center
  }
  .btn{appearance:none;border:0;border-radius:999px;padding:10px 16px;font-weight:700;background:#2563eb;color:#fff;cursor:pointer}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
  <div id="score">Score: 0</div>

  <div id="overlay">
    <div id="startPanel">
      <h2>Flappy Lamumu üêÆ</h2>
      <p style="margin:6px 0 12px;color:#4b5563">Tap / Click untuk flap ¬∑ Tekan <b>C</b> ganti karakter</p>
      <button id="btnStart" class="btn">Start</button>
    </div>
  </div>
</div>

<script>
(() => {
/* ========= Canvas setup ========= */
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const scoreEl=document.getElementById('score');
const overlay=document.getElementById('overlay');
const btnStart=document.getElementById('btnStart');

let W=0,H=0,DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
function resize(){
  W=innerWidth|0; H=innerHeight|0;
  canvas.width=(W*DPR)|0; canvas.height=(H*DPR)|0;
  canvas.style.width=W+'px'; canvas.style.height=H+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize',resize,{passive:true}); resize();

/* ========= Game state ========= */
const state={ running:false, score:0, time:0, gravity:900, flapVel:-400,
  speedBase:190, speedMax:420, speed:190, pipesPassed:0, speedPerPipe:2.2 };

const player={ x:0, y:0, vy:0, r:22 };
const pipes=[];
const bonuses=[];
const PIPE={ width:Math.max(80,(W*0.08)|0), gapBase:Math.max(160,(H*0.28)|0), spawnMin:Math.max(240,(W*0.36)|0), spawnMax:Math.max(280,(W*0.42)|0) };
const BONUS={ sizeBase:Math.max(34,(Math.min(W,H)*0.10)|0), rotateSpeed:2.0, chance:0.65, yOffset:20 };

function rand(a,b){ return a+Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.hypot(dx,dy); }
function circleRect(cx,cy,cr, rx,ry,rw,rh){ const tx=Math.max(rx,Math.min(cx,rx+rw)), ty=Math.max(ry,Math.min(cy,ry+rh)); const dx=cx-tx, dy=cy-ty; return dx*dx+dy*dy<=cr*cr; }

/* ========= Input ========= */
function flap(){ if(state.running){ player.vy = state.flapVel; } }
canvas.addEventListener('mousedown',flap);
canvas.addEventListener('touchstart',e=>{e.preventDefault();flap();},{passive:false});
addEventListener('keydown',e=>{ if(e.code==='Space'){e.preventDefault();flap();} });

btnStart.addEventListener('click',()=>{
  state.running=true; state.score=0; state.time=0; state.pipesPassed=0; state.speed=state.speedBase;
  player.x=Math.max(80,(W*0.18)|0); player.y=(H*0.45)|0; player.vy=0;
  pipes.length=0; bonuses.length=0;
  overlay.style.display='none';
});

/* ========= SKY (4 phase) ========= */
const USE_PROCEDURAL_BG=true;
const BG_CYCLE_MS=60000;      // 60s per fase (demo)
const BG_FADE_MS=1500;
const BG_PARALLAX=0.15;
let cloudOffset1=0, cloudOffset2=0;
let lastDt=1/60;

const phases=[
  { name:'morning', sky:['#FFEDD5','#FDE68A'], sunY:0.35, moon:false, stars:0  },
  { name:'day',     sky:['#BEE3F8','#90CDF4'], sunY:0.22, moon:false, stars:0  },
  { name:'dusk',    sky:['#FECACA','#FBCFE8'], sunY:0.45, moon:false, stars:20 },
  { name:'night',   sky:['#0F172A','#1E293B'], sunY:0.80, moon:true,  stars:80 },
];
let currentBgIndex=0, bgNextIndex=0, bgFadeMsLeft=0;

const STARS=Array.from({length:120},()=>({x:Math.random(),y:Math.random()*0.6,tw:0.5+Math.random()*0.5}));
setInterval(()=>{ bgNextIndex=(currentBgIndex+1)%phases.length; bgFadeMsLeft=BG_FADE_MS; }, BG_CYCLE_MS);

function mixHex(a,b,t){
  const p=n=>parseInt(n,16);
  const A=[p(a.slice(1,3)),p(a.slice(3,5)),p(a.slice(5,7))];
  const B=[p(b.slice(1,3)),p(b.slice(3,5)),p(b.slice(5,7))];
  const C=A.map((v,i)=>Math.round(v+(B[i]-v)*t));
  return `#${C.map(v=>v.toString(16).padStart(2,'0')).join('')}`;
}
function hexToRgb(h){const p=n=>parseInt(n,16);return[p(h.slice(1,3)),p(h.slice(3,5)),p(h.slice(5,7))];}
function drawGradientSky(top,bottom){ const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,top); g.addColorStop(1,bottom); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); }
function drawSun(xNorm,yNorm,alpha=1){
  const R=Math.min(W,H)*0.08; ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle='#FFD166';
  ctx.beginPath(); ctx.arc(xNorm*W,yNorm*H,R,0,Math.PI*2); ctx.fill();
  // halo
  const g=ctx.createRadialGradient(xNorm*W,yNorm*H,R*0.25,xNorm*W,yNorm*H,R*1.6);
  g.addColorStop(0,'rgba(255,209,102,0.70)'); g.addColorStop(1,'rgba(255,209,102,0)');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(xNorm*W,yNorm*H,R*1.6,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawMoon(xNorm,yNorm,alpha=1){
  const R=Math.min(W,H)*0.06; ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle='#E2E8F0';
  ctx.beginPath(); ctx.arc(xNorm*W,yNorm*H,R,0,Math.PI*2); ctx.fill(); ctx.restore();
}
function drawStars(alpha=1){
  ctx.save(); ctx.fillStyle='#E5E7EB';
  for(const s of STARS){
    const tw=0.6+Math.sin(performance.now()/400*s.tw)*0.4;
    ctx.globalAlpha=alpha*tw; ctx.fillRect(s.x*W,s.y*H,2,2);
  }
  ctx.restore();
}
function drawClouds(offset1,offset2,phase){
  const baseA = phase.name==='night' ? 0.45 : 0.92;
  ctx.save(); ctx.globalAlpha=baseA;
  const cloud=(x,y,s)=>{ctx.beginPath();ctx.fillStyle='rgba(255,255,255,0.95)';ctx.arc(x,y,s,0,Math.PI*2);ctx.arc(x+s*0.8,y+s*0.2,s*0.9,0,Math.PI*2);ctx.arc(x-s*0.7,y+s*0.25,s*0.75,0,Math.PI*2);ctx.fill();};
  const y1=H*0.18,y2=H*0.28;
  for(let i=-1;i<=4;i++) cloud((i*0.35*W)+(offset1%W),y1,Math.min(W,H)*0.07);
  ctx.globalAlpha=baseA*0.85;
  for(let i=-1;i<=4;i++) cloud((i*0.50*W)+(offset2%W),y2,Math.min(W,H)*0.055);
  ctx.restore();
}

/* ========= Update & Draw ========= */
function needPipe(){ if(!pipes.length) return true; const last=pipes[pipes.length-1]; return (W-last.x) >= rand(PIPE.spawnMin,PIPE.spawnMax); }
function spawnPipe(){ const gap=PIPE.gapBase, top=rand(50, Math.max(50,H-gap-120)); const p={x:W+10,y:top,width:PIPE.width,gap,passed:false}; pipes.push(p); if(Math.random()<BONUS.chance) spawnBonusAtPipe(p); }
function spawnBonusAtPipe(p){ const mid=p.y+p.gap/2; const y=clamp(mid+(Math.random()-0.5)*2*BONUS.yOffset,p.y+20,p.y+p.gap-20); bonuses.push({x:p.x+PIPE.width+120,y,size:BONUS.sizeBase,angle:0}); }

let last=performance.now();
requestAnimationFrame(function loop(now){
  const dt=Math.min(0.033,(now-last)/1000); last=now;
  if(state.running) update(dt);
  draw(dt);
  requestAnimationFrame(loop);
});

function update(dt){
  lastDt=dt;
  state.time+=dt;
  state.speed=Math.min(state.speedMax, state.speedBase + state.pipesPassed*state.speedPerPipe);
  if(needPipe()) spawnPipe();

  for(let i=pipes.length-1;i>=0;i--){
    const p=pipes[i]; p.x-=state.speed*dt;
    if(p.x+p.width<-10) pipes.splice(i,1);
    if(!p.passed && p.x+p.width<player.x){ p.passed=true; state.pipesPassed++; state.score+=1; }
  }

  player.vy+=state.gravity*dt; player.y+=player.vy*dt;

  for(const p of pipes){
    if(circleRect(player.x,player.y,player.r,p.x,0,p.width,p.y) ||
       circleRect(player.x,player.y,player.r,p.x,p.y+p.gap,p.width,H-(p.y+p.gap))){ return gameOver(); }
  }
  if(player.y>H-2 || player.y<-20) return gameOver();

  for(let i=bonuses.length-1;i>=0;i--){
    const b=bonuses[i]; b.x-=state.speed*dt; b.angle += BONUS.rotateSpeed*dt;
    if(dist(player.x,player.y,b.x,b.y) < (player.r + b.size*0.5*0.8)){ state.score+=100; bonuses.splice(i,1); continue; }
    if(b.x<-80) bonuses.splice(i,1);
  }

  scoreEl.textContent='Score: '+state.score;

  cloudOffset1 = (cloudOffset1 + state.speed * BG_PARALLAX * 0.50 * dt) % W;
  cloudOffset2 = (cloudOffset2 + state.speed * BG_PARALLAX * 0.25 * dt) % W;
}

function gameOver(){
  state.running=false;
  overlay.style.display='flex';
}

/* ========= DRAW ========= */
function draw(dt){
  // Reset state canvas agar tak ada alpha/composite kebawa
  ctx.save();
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.globalAlpha=1;
  ctx.globalCompositeOperation='source-over';

  ctx.clearRect(0,0,W,H);

  if(USE_PROCEDURAL_BG){
    // progres fade fase
    let tFade=0;
    if(bgFadeMsLeft>0){ tFade=1-(bgFadeMsLeft/BG_FADE_MS); bgFadeMsLeft=Math.max(0,bgFadeMsLeft-lastDt*1000); }

    const cur=phases[currentBgIndex];
    const nxt=phases[(currentBgIndex + (tFade>0 ? 1 : 0)) % phases.length];

    // langit
    const skyTop = tFade ? mixHex(cur.sky[0],nxt.sky[0],tFade) : cur.sky[0];
    const skyBot = tFade ? mixHex(cur.sky[1],nxt.sky[1],tFade) : cur.sky[1];
    drawGradientSky(skyTop,skyBot);

    // posisi matahari gerak bolak-balik
    const d=((performance.now()/1000)*0.03)%2;
    const xNorm=(d>1)?(2-d):d;
    const yNorm=tFade? (cur.sunY + (nxt.sunY-cur.sunY)*tFade) : cur.sunY;

    // bintang
    const showStars=(cur.stars>0 || (tFade && nxt.stars>0));
    if(showStars){
      const aCur = cur.stars>0 ? (tFade? (1-tFade):1) : 0;
      const aNxt = nxt.stars>0 ? tFade : 0;
      if(aCur>0) drawStars(aCur);
      if(aNxt>0) drawStars(aNxt);
    }

    // matahari/bulan
    const curSunA  = !cur.moon ? (tFade? (1-tFade):1) : 0;
    const nxtSunA  = !nxt.moon ? tFade : 0;
    const curMoonA =  cur.moon ? (tFade? (1-tFade):1) : 0;
    const nxtMoonA =  nxt.moon ? tFade : 0;
    if(curSunA>0)  drawSun(xNorm,yNorm,curSunA);
    if(nxtSunA>0)  drawSun(xNorm,yNorm,nxtSunA);
    if(curMoonA>0) drawMoon(1-xNorm,yNorm,curMoonA);
    if(nxtMoonA>0) drawMoon(1-xNorm,yNorm,nxtMoonA);

    // awan
    drawClouds(cloudOffset1,cloudOffset2,cur);

    // selesai fade ‚Üí pindah fase
    if(tFade===0 && bgFadeMsLeft===0 && bgNextIndex!==0 && currentBgIndex!==bgNextIndex){
      currentBgIndex=bgNextIndex;
    }

    // auto kontras skor
    const [r,g,b]=hexToRgb(skyTop);
    const f=x=>{x/=255;return x<=0.03928?x/12.92:Math.pow((x+0.055)/1.055,2.4)};
    const L=0.2126*f(r)+0.7152*f(g)+0.0722*f(b);
    scoreEl.style.color=(L<0.45)?'#fff':'#0b1222';
    scoreEl.style.textShadow=(L<0.45)?'0 1px 2px rgba(0,0,0,.6)':'0 1px 2px rgba(255,255,255,.25)';
  }

  // PIPES
  ctx.fillStyle='#1f4fd1';
  for(const p of pipes){
    ctx.fillRect(p.x,0,p.width,p.y);
    ctx.fillRect(p.x,p.y+p.gap,p.width,H-(p.y+p.gap));
  }

  // PLAYER
  if(state.running){
    const s=player.r*2.2;
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.stroke();
  }

  ctx.restore();
}

/* ========= DEBUG helper ========= */
window.clockFreeze = on => { window.__freeze = !!on; };
window.setPhase = name => {
  const map={midnight:3,dawn:0,noon:1,sunset:2};
  const id=map[String(name).toLowerCase()];
  if(id!=null){ currentBgIndex=id; bgNextIndex=(id+1)%phases.length; bgFadeMsLeft=0; }
};

})(); // IIFE
</script>
</body>
</html>
