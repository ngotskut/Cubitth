<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Flappy Lamumu ‚Äî Orbit Sky + Landscape (Fix Brightness)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000}
  #wrap{position:fixed;inset:0}
  #game{position:absolute;inset:0;display:block}
  #score{position:absolute;top:8px;left:50%;transform:translateX(-50%);
    font-weight:800;font-size:18px;pointer-events:none}
  #overlay{position:absolute;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:8}
  #startPanel{
    width:min(600px,92vw);background:rgba(255,255,255,.96);border-radius:18px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);padding:22px 20px;text-align:center
  }
  .btn{appearance:none;border:0;border-radius:999px;padding:10px 16px;
    font-weight:700;background:#2563eb;color:#fff;cursor:pointer}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
  <div id="score">Score: 0</div>
  <div id="overlay">
    <div id="startPanel">
      <h2>Flappy Lamumu üêÆ</h2>
      <p style="margin:6px 0 12px;color:#4b5563">Tap / Klik untuk flap ¬∑ Tekan <b>Space</b> juga bisa</p>
      <button id="btnStart" class="btn">Start</button>
    </div>
  </div>
</div>

<script>
(()=>{
/* ================= Canvas & State ================= */
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const scoreEl=document.getElementById('score');
const overlay=document.getElementById('overlay');
const btnStart=document.getElementById('btnStart');

let W=0,H=0,DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
function resize(){ W=innerWidth|0; H=innerHeight|0;
  canvas.width=W*DPR; canvas.height=H*DPR;
  canvas.style.width=W+'px'; canvas.style.height=H+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize',resize,{passive:true}); resize();

const state={
  running:false, score:0, time:0,
  gravity:900, flapVel:-400,
  speedBase:190, speedMax:420, speed:190,
  pipesPassed:0, speedPerPipe:2.2
};
const player={x:0,y:0,vy:0,r:Math.max(22,(Math.min(W,H)*0.024)|0)};
const pipes=[];

function flap(){ if(state.running){ player.vy=state.flapVel; } }
canvas.addEventListener('mousedown',flap);
canvas.addEventListener('touchstart',e=>{e.preventDefault();flap();},{passive:false});
addEventListener('keydown',e=>{ if(e.code==='Space'){e.preventDefault();flap();} });

btnStart.onclick=()=>{
  state.running=true; state.score=0; state.time=0; state.pipesPassed=0; state.speed=state.speedBase;
  player.x=Math.max(80,(W*0.18)|0); player.y=(H*0.45)|0; player.vy=0;
  pipes.length=0; overlay.style.display='none';
};

/* ================= Orbit & Sky ================= */
const DAY_SEC = 60;   // 60 detik/siklus
let dayClock = 0;

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const smooth01=t=>t<=0?0:t>=1?1:t*t*(3-2*t);
const lerp=(a,b,t)=>a+(b-a)*t;
const lerpColor=(c1,c2,t)=>{
  const p=n=>parseInt(n,16);
  const [r1,g1,b1]=[p(c1.slice(1,3)),p(c1.slice(3,5)),p(c1.slice(5,7))];
  const [r2,g2,b2]=[p(c2.slice(1,3)),p(c2.slice(3,5)),p(c2.slice(5,7))];
  return `rgb(${(r1+(r2-r1)*t)|0},${(g1+(g2-g1)*t)|0},${(b1+(b2-b1)*t)|0})`;
};
const hexToRgb=h=>[parseInt(h.slice(1,3),16),parseInt(h.slice(3,5),16),parseInt(h.slice(5,7),16)];

const horizonY = ()=> H*0.62;

function sunPos(frac){
  // mulai SIANG (matahari tepat di atas) saat frac=0
  const cx=W*0.5, cy=horizonY(), rx=W*0.42, ry=H*0.36;
  const ang = frac*2*Math.PI + Math.PI/2; // frac=0 ‚Üí œÄ/2 (di atas)
  return { x:cx+Math.cos(ang)*rx, y:cy - Math.sin(ang)*ry };
}
function moonPos(frac){
  const cx=W*0.5, cy=horizonY(), rx=W*0.42, ry=H*0.36;
  const ang = frac*2*Math.PI + Math.PI/2 + Math.PI; // berlawanan 180¬∞
  return { x:cx+Math.cos(ang)*rx, y:cy - Math.sin(ang)*ry };
}

// Bintang berkedip
const STARS=Array.from({length:160},()=>({x:Math.random(),y:Math.random()*0.6,tw:0.6+Math.random()*0.6}));
function drawStars(alpha){
  if(alpha<=0.01) return;
  ctx.save();
  for(const s of STARS){
    const tw = 0.6 + Math.sin(performance.now()/420*s.tw)*0.4;
    ctx.globalAlpha = alpha*tw;
    ctx.fillStyle='#e8eefc';
    ctx.fillRect(s.x*W, s.y*H, 2, 2);
  }
  ctx.restore();
}

// Awan parallax
let cloud1=0, cloud2=0;
function drawClouds(bright){
  const baseA = lerp(0.55, 0.92, bright); // malam tipis ‚Üí siang padat
  ctx.save();
  const cloud=(x,y,s)=>{
    ctx.beginPath();
    ctx.fillStyle='rgba(255,255,255,0.96)';
    ctx.arc(x,y,s,0,Math.PI*2);
    ctx.arc(x+s*0.8,y+s*0.2,s*0.95,0,Math.PI*2);
    ctx.arc(x-s*0.7,y+s*0.25,s*0.85,0,Math.PI*2);
    ctx.fill();
  };
  ctx.globalAlpha=baseA;
  const y1=H*0.18,y2=H*0.28,s1=Math.min(W,H)*0.07,s2=Math.min(W,H)*0.055;
  for(let i=-1;i<=4;i++) cloud((i*0.35*W)+(cloud1%W),y1,s1);
  ctx.globalAlpha=baseA*0.85;
  for(let i=-1;i<=4;i++) cloud((i*0.50*W)+(cloud2%W),y2,s2);
  ctx.restore();
}

// Sun & Moon (tanpa garis horizon)
function drawSun(x,y,elev){
  const R=Math.min(W,H)*0.08;
  ctx.save();
  const coreA = elev>0 ? 1 : 0.15; // di bawah horizon masih sedikit tampak
  ctx.globalAlpha=coreA;
  ctx.fillStyle='#FFD166';
  ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.fill();
  if(elev>0.05){
    const g=ctx.createRadialGradient(x,y,R*0.2,x,y,R*1.6);
    g.addColorStop(0,'rgba(255,209,102,0.55)');
    g.addColorStop(1,'rgba(255,209,102,0)');
    ctx.globalAlpha=0.9;
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,R*1.6,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}
function drawMoon(x,y,elev){
  if(elev<=0) return;
  const R=Math.min(W,H)*0.06;
  ctx.save(); ctx.globalAlpha=elev*0.9; ctx.fillStyle='#E2E8F0';
  ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.fill(); ctx.restore();
}

/* ================= Landscape (stylized like reference) ================= */
/* helper: mix color with darkness based on brightness (0..1) */
function shade(hex, k){ // k=0 ‚Üí gelap malam, k=1 ‚Üí warna asli
  // campur dari #0b1a22 (malam) ke warna aslinya
  return lerpColor('#0b1a22', hex, clamp(k,0,1));
}

/* generic gradient fill for a closed path */
function fillVerticalGradient(yTop, yBottom, topColor, botColor){
  const g = ctx.createLinearGradient(0, yTop, 0, yBottom);
  g.addColorStop(0, topColor);
  g.addColorStop(1, botColor);
  ctx.fillStyle = g;
  ctx.fill();
}

/* far mountain ridge with smooth curves */
function drawFarRidge({y, amp, wobble=1.0, seed=0, peaks=10, top, bot}){
  const seg = W/peaks;
  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(0, y);
  for(let i=1;i<=peaks;i++){
    const x = i*seg;
    const t = seed + (i/peaks)*Math.PI*2;
    const n = Math.sin(t)*0.55 + Math.sin(t*1.9+1.1)*0.25;
    const yy = y - amp*(0.5 + n*0.33*wobble);
    const cx = x - seg*0.5;
    const cy = y - amp*(0.5 + Math.sin(t-0.6)*0.25*wobble);
    ctx.quadraticCurveTo(cx, cy, x, yy);
  }
  ctx.lineTo(W, H);
  ctx.closePath();
  fillVerticalGradient(y-amp-40, H, top, bot);
}

/* big left/right foreground hills (valley shape like reference) */
function drawSideHill(side, {yBase, height, curve=0.55, top, bot}){
  // anchor positions
  const valleyX = W*0.52;
  const peakX   = side==='left' ? W*0.18 : W*0.82;
  const startX  = side==='left' ? 0 : W;
  const ctrlDir = side==='left' ? 1 : -1;

  ctx.beginPath();
  ctx.moveTo(startX, H);
  ctx.lineTo(startX, yBase);

  // from edge to peak
  ctx.quadraticCurveTo(
    startX + ctrlDir*W*0.10, yBase - height*0.35,
    peakX,                   yBase - height
  );
  // from peak down to valley
  ctx.quadraticCurveTo(
    peakX  + ctrlDir*W*curve*0.25, yBase - height*0.55,
    valleyX,                       yBase - height*0.15
  );

  // close to bottom
  ctx.lineTo(W, H);
  ctx.closePath();
  fillVerticalGradient(yBase-height-60, H, top, bot);
}

/* soft highlight stripes on hills */
function drawHillStripes(side, {yBase, height, color='#a7e37d', count=3}){
  const valleyX = W*0.52;
  const peakX   = side==='left' ? W*0.18 : W*0.82;
  const dir     = side==='left' ? 1 : -1;

  for(let k=0;k<count;k++){
    const off = (k+1)*height*0.18;
    ctx.save();
    ctx.globalAlpha = 0.18 - k*0.05;
    ctx.strokeStyle = color;
    ctx.lineWidth   = Math.max(2, H*0.006);

    ctx.beginPath();
    const y1 = (yBase - height*0.65) + off;
    ctx.moveTo(peakX, y1);
    const midY = (yBase - height*0.28) + off*0.75;
    ctx.quadraticCurveTo(peakX + dir*W*0.18, y1 + H*0.04, valleyX, midY);
    ctx.stroke();
    ctx.restore();
  }
}

/* rounded bush row in the very front */
function drawBushRow({y, size, gap, speed, time, color}){
  ctx.save(); ctx.fillStyle=color;
  const off=(time*speed*0.06)%gap;
  for(let x=-gap;x<W+gap;x+=gap){
    const cx=x+off, r=size;
    ctx.beginPath();
    ctx.arc(cx, y, r, 0, Math.PI*2);
    ctx.arc(cx+r*0.9, y+r*0.1, r*0.95, 0, Math.PI*2);
    ctx.arc(cx-r*0.9, y+r*0.15, r*0.85, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

/* subtle valley fog */
function drawFog(yTop,yBot,alpha){
  const g=ctx.createLinearGradient(0,yTop,0,yBot);
  g.addColorStop(0,`rgba(255,255,255,${alpha})`);
  g.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=g; ctx.fillRect(0,yTop,W,yBot-yTop);
}

/* === main: call this from draw(...): drawLandscape(state.time, bright) === */
function drawLandscape(t, bright){
  // map brightness (0..1) ‚Üí tint factor (malam lebih gelap)
  const k = 0.45 + bright*0.55;

  // ‚Äî far ridges (biru kehijauan) ‚Äî mirip referensi
  drawFarRidge({
    y:H*0.70, amp:H*0.10, peaks:10, seed:t*0.6,
    top: shade('#8cc7d4', k*0.95),
    bot: shade('#6fb3c7', k*0.90)
  });
  drawFarRidge({
    y:H*0.77, amp:H*0.12, peaks:9, seed:1.7+t*0.9,
    top: shade('#6bb2c0', k*0.92),
    bot: shade('#4b90aa', k*0.88)
  });

  // sedikit kabut lembah (lebih pekat saat malam)
  drawFog(H*0.72, H*0.82, (1-bright)*0.10);

  // ‚Äî mid ridge (teal) ‚Äî
  drawFarRidge({
    y:H*0.83, amp:H*0.16, peaks:8, seed:3.1+t*1.2,
    top: shade('#4aa070', k*0.95),
    bot: shade('#2e7b54', k*0.92)
  });
  drawFog(H*0.80, H*0.88, (1-bright)*0.08);

  // ‚Äî foreground left/right hills (hijau terang) ‚Äî
  const topGreen = shade('#45ad53', k);
  const botGreen = shade('#2d7c35', k*0.95);

  drawSideHill('left',  { yBase:H*0.94, height:H*0.34, top:topGreen, bot:botGreen });
  drawHillStripes('left',  { yBase:H*0.94, height:H*0.34, color:shade('#b8f499', k), count:3 });

  drawSideHill('right', { yBase:H*0.94, height:H*0.34, top:topGreen, bot:botGreen });
  drawHillStripes('right', { yBase:H*0.94, height:H*0.34, color:shade('#b8f499', k), count:3 });

  // ‚Äî bush paling depan ‚Äî
  drawBushRow({
    y:H*0.965, size:Math.min(W,H)*0.05, gap:Math.min(W,H)*0.22,
    speed:30, time:t, color:shade('#0f4d1f', k*0.85)
  });
}

/* ================= Pipes (rintangan) ================= */
const PIPE={
  width: Math.max(80,(W*0.08)|0),
  gapBase: Math.max(160,(H*0.28)|0),
  spawnMin: Math.max(240,(W*0.36)|0),
  spawnMax: Math.max(280,(W*0.42)|0)
};
function rand(a,b){ return a+Math.random()*(b-a); }
function needPipe(){ if(!pipes.length) return true; const last=pipes[pipes.length-1]; return (W-last.x) >= rand(PIPE.spawnMin,PIPE.spawnMax); }
function spawnPipe(){
  const gap=PIPE.gapBase;
  const top=rand(50, Math.max(50,H-gap-120));
  pipes.push({x:W+10,y:top,width:PIPE.width,gap,passed:false});
}
function circleRect(cx,cy,cr, rx,ry,rw,rh){ const tx=Math.max(rx,Math.min(cx,rx+rw)), ty=Math.max(ry,Math.min(cy,ry+rh)); const dx=cx-tx, dy=cy-ty; return dx*dx+dy*dy<=cr*cr; }

/* ================= Loop ================= */
let last=performance.now();
requestAnimationFrame(function loop(now){
  let dt=(now-last)/1000; if(dt>0.033) dt=0.033; if(dt<=0) dt=1/60;
  last=now;

  dayClock = (dayClock + dt) % DAY_SEC;

  if(state.running) update(dt);
  draw(dt);
  requestAnimationFrame(loop);
});

function update(dt){
  state.time+=dt;
  state.speed=Math.min(state.speedMax, state.speedBase + state.pipesPassed*state.speedPerPipe);

  if(needPipe()) spawnPipe();
  for(let i=pipes.length-1;i>=0;i--){
    const p=pipes[i]; p.x -= state.speed*dt;
    if(p.x + p.width < -10) pipes.splice(i,1);
    if(!p.passed && p.x + p.width < player.x){ p.passed=true; state.pipesPassed++; state.score+=1; }
  }

  player.vy += state.gravity*dt; player.y += player.vy*dt;

  for(const p of pipes){
    if(circleRect(player.x,player.y,player.r,p.x,0,p.width,p.y) ||
       circleRect(player.x,player.y,player.r,p.x,p.y+p.gap,p.width,H-(p.y+p.gap))){ return gameOver(); }
  }
  if(player.y>H-2 || player.y<-20) return gameOver();

  // awan parallax
  const v = state.running ? state.speed : 120;
  cloud1 = (cloud1 + v*0.05*dt) % W;
  cloud2 = (cloud2 + v*0.03*dt) % W;

  scoreEl.textContent='Score: '+state.score;
}
function gameOver(){ state.running=false; overlay.style.display='flex'; }

/* ================= Draw ================= */
function draw(){
  const frac = (dayClock % DAY_SEC) / DAY_SEC;

  // posisi orbit
  const sun  = sunPos(frac);
  const moon = moonPos(frac);

  // >>> brightness dari POSISI LAYAR (fix tidak sinkron) <<<
  // elev ~ 1 saat jauh di atas horizon, ~ -1 saat jauh di bawah
  const elev = clamp( (horizonY() - sun.y) / (H*0.36), -1, 1 );

  // day brightness
  const sigmoid=(x,k=6,offset=-0.08)=>1/(1+Math.exp(-k*(x-offset)));
  const baseBright = sigmoid(elev);
  const dawnBoost  = smooth01(clamp((elev+0.18)/0.22,0,1))*0.15;
  const bright     = clamp(0.10 + 0.85*baseBright + dawnBoost, 0, 1);

  // warna langit utama
  const nightTop='#0a0f1e', nightBot='#121a2c';
  const dayTop  ='#7fd0ff', dayBot  ='#d8f2ff';
  let skyTop = lerpColor(nightTop, dayTop, bright);
  let skyBot = lerpColor(nightBot, dayBot, bright);

  // tint senja/subuh dekat horizon
  const gauss=(x,s)=>Math.exp(-(x*x)/(2*s*s));
  const sunsetK = gauss(elev-0.02,0.12);
  const dawnK   = gauss(elev+0.05,0.14);
  skyTop = lerpColor(skyTop, '#ff9b5e', Math.min(1, sunsetK*0.9));
  skyBot = lerpColor(skyBot, '#ffd39a', Math.min(1, sunsetK*0.9));
  skyTop = lerpColor(skyTop, '#244b9a', Math.min(1, dawnK*0.7));
  skyBot = lerpColor(skyBot, '#3e74c9', Math.min(1, dawnK*0.7));

  // gambar langit
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, skyTop); g.addColorStop(1, skyBot);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // bintang (menghilang ketika terang)
  const starA = 1 - smooth01(clamp((elev+0.06)/0.18,0,1));
  drawStars(starA);

  // bulan (muncul saat di atas horizon kebalikan matahari)
  const moonElev = clamp( (horizonY() - moon.y) / (H*0.36), -1, 1 );
  drawMoon(moon.x, moon.y, Math.max(0, moonElev));
  drawSun (sun.x,  sun.y,  elev);

  // awan & landscape
  drawClouds(bright);
  drawLandscape(state.time, bright);

  // pipes
  ctx.fillStyle='#1f4fd1';
  for(const p of pipes){
    ctx.fillRect(p.x,0,p.width,p.y);
    ctx.fillRect(p.x,p.y+p.gap,p.width,H-(p.y+p.gap));
  }

  // player
  if(state.running){
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2);
    ctx.fillStyle='#fff'; ctx.fill();
    ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.stroke();
  }

  // kontras skor otomatis
  const [r,g2,b]=hexToRgb(skyTop.replace('rgb(','#').replace(')','')); // fallback aman
  const f=x=>{x/=255;return x<=0.03928?x/12.92:Math.pow((x+0.055)/1.055,2.4)};
  const L=0.2126*f(r||127)+0.7152*f(g2||170)+0.0722*f(b||255);
  scoreEl.style.color=(L<0.45)?'#fff':'#0b1222';
  scoreEl.style.textShadow=(L<0.45)?'0 2px 6px rgba(0,0,0,.8)':'0 1px 2px rgba(255,255,255,.25)';
}

/* ====== Debug helpers ====== */
window.setNoon     = ()=>{ dayClock = 0.00*DAY_SEC; };  // siang bolong
window.setSunset   = ()=>{ dayClock = 0.25*DAY_SEC; };
window.setMidnight = ()=>{ dayClock = 0.50*DAY_SEC; };
window.setDawn     = ()=>{ dayClock = 0.75*DAY_SEC; };

})();
</script>
</body>
</html>
